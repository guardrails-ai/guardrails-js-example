import { ReAsk } from '../outputs/reask.js';
import { ValidatorLogs } from '../outputs/validator-logs.js';
import { Stack } from '../structs/stack.js';
import { determine } from '../utils/determine.js';
import { map } from '../utils/map.js';
import { CallInputs } from './call-inputs.js';
import { Iteration } from './iteration.js';
export class Call {
    /**
     * A stack of iterations for each step/reask that occurred during this call.
     */
    _iterations;
    /**
     * The inputs as passed in to Guard.__call__ or Guard.parse
     */
    _inputs;
    /**
     * The prompt as provided by the user when intializing or calling the Guard.
    */
    _prompt;
    /**
     * The prompt parameters as provided by the user when intializing or calling the Guard.
    */
    _promptParams;
    /**
     * The initial compiled prompt that was passed to the LLM on the first call.
    */
    _compiledPrompt;
    /**
     * The compiled prompts used during reasks.
     * Does not include the initial prompt.
    */
    _reaskPrompts;
    /**
     * The instructions as provided by the user when intializing or calling the Guard.
    */
    _instructions;
    /**
     * The initial compiled instructions that were passed to the LLM on the first call.
    */
    _compiledInstructions;
    /**
     * The compiled instructions used during reasks.
     * Does not include the initial instructions.
    */
    _reaskInstructions;
    /**
     * Returns all logs from all iterations as a stack.
    */
    _logs;
    /**
     * Returns the total number of tokens consumed during all iterations with this call.
    */
    _tokensConsumed;
    /**
     * Returns the total number of prompt tokens consumed during all iterations with this call.
    */
    _promptTokensConsumed;
    /**
     * Returns the total number of completion tokens consumed during all iterations with this call.
    */
    _completionTokensConsumed;
    /**
     * The exact outputs from all LLM calls.
    */
    _rawOutputs;
    /**
     * The outputs from the LLM after undergoing parsing but before validation.
    */
    _parsedOutputs;
    /**
     * The cumulative validation output across all current iterations.
     * Could contain ReAsks.
    */
    _validationOutput;
    /**
     * The cumulative validation output across all current iterations with any automatic fixes applied.
    */
    _fixedOutput;
    /**
     * The output from the LLM after undergoing validation.
     * This will only have a value if the Guard is in a passing state.
    */
    _validatedOutput;
    /**
     * Reasks generated during validation that could not be automatically fixed.
     * These would be incorporated into the prompt for the next LLM call if additional reasks were granted.
    */
    _reasks;
    /**
     * The results of each individual validation performed on the LLM responses during all iterations.
    */
    _validatorLogs;
    /**
     * The error message from any exception that raised and interrupted the run.
    */
    _error;
    /**
     * The exception that interrupted the run.
    */
    _exception;
    /**
     * The validator logs for any validations that failed during the entirety of the run.
    */
    _failedValidations;
    /**
     * Returns the cumulative status of the run based on the validity of the final merged output.
     */
    _status;
    constructor(call) {
        const { iterations = new Stack(), inputs = new CallInputs(), prompt, promptParams, compiledPrompt, reaskPrompts = new Stack(), instructions, compiledInstructions, reaskInstructions = new Stack(), logs = new Stack(), tokensConsumed, promptTokensConsumed, completionTokensConsumed, rawOutputs = new Stack(), parsedOutputs = new Stack(), validationOutput, fixedOutput, validatedOutput, reasks = new Stack(), validatorLogs = new Stack(), error, exception, failedValidations = new Stack(), status } = call;
        this._iterations = iterations;
        this._inputs = inputs;
        this._prompt = prompt;
        this._promptParams = promptParams;
        this._compiledPrompt = compiledPrompt;
        this._reaskPrompts = reaskPrompts;
        this._instructions = instructions;
        this._compiledInstructions = compiledInstructions;
        this._reaskInstructions = reaskInstructions;
        this._logs = logs;
        this._tokensConsumed = tokensConsumed;
        this._promptTokensConsumed = promptTokensConsumed;
        this._completionTokensConsumed = completionTokensConsumed;
        this._rawOutputs = rawOutputs;
        this._parsedOutputs = parsedOutputs;
        this._validationOutput = validationOutput;
        this._fixedOutput = fixedOutput;
        this._validatedOutput = validatedOutput;
        this._reasks = reasks;
        this._validatorLogs = validatorLogs;
        this._error = error;
        this._exception = exception;
        this._failedValidations = failedValidations;
        this._status = status;
    }
    static async fromPyCall(pyCall) {
        let iterations, inputs, prompt, promptParams, compiledPrompt, reaskPrompts, instructions, compiledInstructions, reaskInstructions, logs, tokensConsumed, promptTokensConsumed, completionTokensConsumed, rawOutputs, parsedOutputs, validationOutput, fixedOutput, validatedOutput, reasks, validatorLogs, error, exception, failedValidations, status;
        try {
            const pyIterations = await pyCall?.iterations;
            const iterationArray = await map(pyIterations, (Iteration.fromPyIteration));
            iterations = new Stack(...iterationArray);
            const pyInputs = await pyCall?.inputs;
            inputs = await CallInputs.fromPyCallInputs(pyInputs);
            prompt = await pyCall?.prompt;
            promptParams = await determine(pyCall?.prompt_params);
            compiledPrompt = await pyCall?.compiled_prompt;
            const pyReaskPrompts = await pyCall?.reask_prompts;
            const reaskPromptsArray = await map(pyReaskPrompts, (v) => v.valueOf());
            reaskPrompts = new Stack(...reaskPromptsArray);
            instructions = await pyCall?.instructions;
            compiledInstructions = await pyCall?.compiled_instructions;
            const pyReaskInstructions = await pyCall?.reask_instructions;
            const reaskInstructionsArray = await map(pyReaskInstructions, (v) => v.valueOf());
            reaskInstructions = new Stack(...reaskInstructionsArray);
            const pyLogs = await pyCall?.logs;
            const logsArray = await map(pyLogs, (v) => v.valueOf());
            logs = new Stack(...logsArray);
            tokensConsumed = await determine(pyCall?.tokens_consumed);
            promptTokensConsumed = await determine(pyCall?.prompt_tokens_consumed);
            completionTokensConsumed = await determine(pyCall?.completion_tokens_consumed);
            const pyRawOutputs = await pyCall?.raw_outputs;
            const rawOutputsArray = await map(pyRawOutputs, (v) => v.valueOf());
            rawOutputs = new Stack(...rawOutputsArray);
            const pyParsedOutputs = await pyCall?.parsed_outputs;
            const parsedOutputsArray = await map(pyParsedOutputs, (v) => v.valueOf());
            parsedOutputs = new Stack(...parsedOutputsArray);
            validationOutput = await determine(pyCall?.validation_output);
            fixedOutput = await determine(pyCall?.fixed_output);
            validatedOutput = await determine(pyCall?.validated_output);
            const pyReasks = await pyCall?.reasks;
            const reasksArray = await map(pyReasks, ReAsk.fromPyReAsk);
            reasks = new Stack(...reasksArray);
            const pyValidatorLogs = await pyCall?.validator_logs;
            const validatorLogsArray = await map(pyValidatorLogs, ValidatorLogs.fromPyValidatorLogs);
            validatorLogs = new Stack(...validatorLogsArray);
            error = await pyCall?.error;
            exception = await determine(pyCall?.exception);
            const pyFailedValidations = await pyCall?.failed_validations;
            const failedValidationsArray = await map(pyFailedValidations, ValidatorLogs.fromPyValidatorLogs);
            failedValidations = new Stack(...failedValidationsArray);
            status = await pyCall?.status;
        }
        catch (err) {
            console.error('An error occurred while parsing a Call from python to javascript.', err);
        }
        return new Call({
            iterations,
            inputs,
            prompt,
            promptParams,
            compiledPrompt,
            reaskPrompts,
            instructions,
            compiledInstructions,
            reaskInstructions,
            logs,
            tokensConsumed,
            promptTokensConsumed,
            completionTokensConsumed,
            rawOutputs,
            parsedOutputs,
            validationOutput,
            fixedOutput,
            validatedOutput,
            reasks,
            validatorLogs,
            error,
            exception,
            failedValidations,
            status
        });
    }
    get iterations() {
        return this._iterations;
    }
    get inputs() {
        return this._inputs;
    }
    get prompt() {
        return this._prompt;
    }
    get promptParams() {
        return this._promptParams;
    }
    get compiledPrompt() {
        return this._compiledPrompt;
    }
    get reaskPrompts() {
        return this._reaskPrompts;
    }
    get instructions() {
        return this._instructions;
    }
    get compiledInstructions() {
        return this._compiledInstructions;
    }
    get reaskInstructions() {
        return this._reaskInstructions;
    }
    get logs() {
        return this._logs;
    }
    get tokensConsumed() {
        return this._tokensConsumed;
    }
    get promptTokensConsumed() {
        return this._promptTokensConsumed;
    }
    get completionTokensConsumed() {
        return this._completionTokensConsumed;
    }
    get rawOutputs() {
        return this._rawOutputs;
    }
    get parsedOutputs() {
        return this._parsedOutputs;
    }
    get validationOutput() {
        return this._validationOutput;
    }
    get fixedOutput() {
        return this._fixedOutput;
    }
    get validatedOutput() {
        return this._validatedOutput;
    }
    get reasks() {
        return this._reasks;
    }
    get validatorLogs() {
        return this._validatorLogs;
    }
    get error() {
        return this._error;
    }
    get exception() {
        return this._exception;
    }
    get failedValidations() {
        return this._failedValidations;
    }
    get status() {
        return this._status;
    }
}
