import { ReAsk } from '../outputs/reask.js';
import { ValidatorLogs } from '../outputs/validator-logs.js';
import { Stack } from '../structs/stack.js';
import { Dictionary } from '../types.js';
import { CallInputs } from './call-inputs.js';
import { Iteration } from './iteration.js';
export interface ICall<T> {
    iterations?: Stack<Iteration<T>>;
    inputs?: CallInputs;
    prompt?: string;
    promptParams?: Dictionary;
    compiledPrompt?: string;
    reaskPrompts?: Stack<string>;
    instructions?: string;
    compiledInstructions?: string;
    reaskInstructions?: Stack<string>;
    logs?: Stack<string>;
    tokensConsumed?: number;
    promptTokensConsumed?: number;
    completionTokensConsumed?: number;
    rawOutputs?: Stack<string>;
    parsedOutputs?: Stack<T>;
    validationOutput?: T | ReAsk;
    fixedOutput?: T;
    validatedOutput?: T;
    reasks?: Stack<ReAsk>;
    validatorLogs?: Stack<ValidatorLogs>;
    error?: string;
    exception?: Error;
    failedValidations?: Stack<ValidatorLogs>;
    status?: string;
}
export declare class Call<T> implements ICall<T> {
    /**
     * A stack of iterations for each step/reask that occurred during this call.
     */
    private _iterations;
    /**
     * The inputs as passed in to Guard.__call__ or Guard.parse
     */
    private _inputs;
    /**
     * The prompt as provided by the user when intializing or calling the Guard.
    */
    private _prompt?;
    /**
     * The prompt parameters as provided by the user when intializing or calling the Guard.
    */
    private _promptParams?;
    /**
     * The initial compiled prompt that was passed to the LLM on the first call.
    */
    private _compiledPrompt?;
    /**
     * The compiled prompts used during reasks.
     * Does not include the initial prompt.
    */
    private _reaskPrompts;
    /**
     * The instructions as provided by the user when intializing or calling the Guard.
    */
    private _instructions?;
    /**
     * The initial compiled instructions that were passed to the LLM on the first call.
    */
    private _compiledInstructions?;
    /**
     * The compiled instructions used during reasks.
     * Does not include the initial instructions.
    */
    private _reaskInstructions;
    /**
     * Returns all logs from all iterations as a stack.
    */
    private _logs;
    /**
     * Returns the total number of tokens consumed during all iterations with this call.
    */
    private _tokensConsumed?;
    /**
     * Returns the total number of prompt tokens consumed during all iterations with this call.
    */
    private _promptTokensConsumed?;
    /**
     * Returns the total number of completion tokens consumed during all iterations with this call.
    */
    private _completionTokensConsumed?;
    /**
     * The exact outputs from all LLM calls.
    */
    private _rawOutputs;
    /**
     * The outputs from the LLM after undergoing parsing but before validation.
    */
    private _parsedOutputs;
    /**
     * The cumulative validation output across all current iterations.
     * Could contain ReAsks.
    */
    private _validationOutput?;
    /**
     * The cumulative validation output across all current iterations with any automatic fixes applied.
    */
    private _fixedOutput?;
    /**
     * The output from the LLM after undergoing validation.
     * This will only have a value if the Guard is in a passing state.
    */
    private _validatedOutput?;
    /**
     * Reasks generated during validation that could not be automatically fixed.
     * These would be incorporated into the prompt for the next LLM call if additional reasks were granted.
    */
    private _reasks;
    /**
     * The results of each individual validation performed on the LLM responses during all iterations.
    */
    private _validatorLogs;
    /**
     * The error message from any exception that raised and interrupted the run.
    */
    private _error?;
    /**
     * The exception that interrupted the run.
    */
    private _exception?;
    /**
     * The validator logs for any validations that failed during the entirety of the run.
    */
    private _failedValidations;
    /**
     * Returns the cumulative status of the run based on the validity of the final merged output.
     */
    private _status?;
    constructor(call: ICall<T>);
    static fromPyCall<U>(pyCall: any): Promise<Call<U>>;
    get iterations(): Stack<Iteration<T>>;
    get inputs(): CallInputs;
    get prompt(): string | undefined;
    get promptParams(): Dictionary | undefined;
    get compiledPrompt(): string | undefined;
    get reaskPrompts(): Stack<string>;
    get instructions(): string | undefined;
    get compiledInstructions(): string | undefined;
    get reaskInstructions(): Stack<string>;
    get logs(): Stack<string>;
    get tokensConsumed(): number | undefined;
    get promptTokensConsumed(): number | undefined;
    get completionTokensConsumed(): number | undefined;
    get rawOutputs(): Stack<string>;
    get parsedOutputs(): Stack<T>;
    get validationOutput(): T | ReAsk | undefined;
    get fixedOutput(): T | undefined;
    get validatedOutput(): T | undefined;
    get reasks(): Stack<ReAsk>;
    get validatorLogs(): Stack<ValidatorLogs>;
    get error(): string | undefined;
    get exception(): Error | undefined;
    get failedValidations(): Stack<ValidatorLogs>;
    get status(): string | undefined;
}
//# sourceMappingURL=call.d.ts.map