import { ReAsk } from '../outputs/reask.js';
import { ValidatorLogs } from '../outputs/validator-logs.js';
import { Stack } from '../structs/stack.js';
import { determine } from '../utils/determine.js';
import { map } from '../utils/map.js';
import { Inputs } from './inputs.js';
import { Outputs } from './outputs.js';
export class Iteration {
    /**
    * The inputs for the iteration/step.
    */
    _inputs;
    /**
    * The outputs from the iteration/step.
    */
    _outputs;
    /**
    * Returns the logs from this iteration as a stack.
    */
    _logs;
    /**
    * Returns the total number of tokens consumed during this iteration.
    */
    _tokensConsumed;
    /**
    *  Returns the number of prompt/input tokens consumed during this iteration.
    */
    _promptTokensConsumed;
    /**
    * Returns the number of completion/output tokens consumed during this iteration.
    */
    _completionTokensConsumed;
    /**
    * The exact output from the LLM.
    */
    _rawOutput;
    /**
    * The output from the LLM after undergoing parsing but before validation.
    */
    _parsedOutput;
    /**
    * The output from the validation process.
    * Could be a combination of valid output and ReAsks
    */
    _validationOutput;
    /**
    * The valid output from the LLM after undergoing validation.
    * Could be only a partial structure if field level reasks occur.
    * Could contain fixed values.
    */
    _validatedOutput;
    /**
    * Reasks generated during validation.
    * These would be incorporated into the prompt or the next LLM call.
    */
    _reasks;
    /**
    * The results of each individual validation performed on the LLM response during this iteration.
    */
    _validatorLogs;
    /**
    * The error message from any exception that raised and interrupted this iteration.
    */
    _error;
    /**
    * The exception that interrupted this iteration.
    */
    _exception;
    /**
    * The validator logs for any validations that failed during this iteration.
    */
    _failedValidations;
    /**
    * Representation of the end state of this iteration.
    * OneOf: pass, fail, error, not run
    */
    _status;
    constructor(inputs, outputs, logs, tokensConsumed, promptTokensConsumed, completionTokensConsumed, rawOutput, parsedOutput, validationOutput, validatedOutput, reasks, validatorLogs, error, exception, failedValidations, status) {
        this._inputs = inputs || new Inputs();
        this._outputs = outputs || new Outputs();
        this._logs = logs || new Stack();
        this._tokensConsumed = tokensConsumed;
        this._promptTokensConsumed = promptTokensConsumed;
        this._completionTokensConsumed = completionTokensConsumed;
        this._rawOutput = rawOutput;
        this._parsedOutput = parsedOutput;
        this._validationOutput = validationOutput;
        this._validatedOutput = validatedOutput;
        this._reasks = reasks;
        this._validatorLogs = validatorLogs;
        this._error = error;
        this._exception = exception;
        this._failedValidations = failedValidations;
        this._status = status;
    }
    static async fromPyIteration(pyIteration) {
        let inputs, outputs, logs, tokensConsumed, promptTokensConsumed, completionTokensConsumed, rawOutput, parsedOutput, validationOutput, validatedOutput, reasks, validatorLogs, error, exception, failedValidations, status;
        try {
            const pyInputs = await pyIteration?.inputs;
            inputs = await Inputs.fromPyInputs(pyInputs);
            const pyOutputs = await pyIteration?.outputs;
            outputs = await Outputs.fromPyOutputs(pyOutputs);
            const pyLogs = await determine(pyIteration?.logs) || [];
            logs = new Stack(...pyLogs);
            tokensConsumed = await determine(pyIteration?.tokens_consumed);
            promptTokensConsumed = await determine(pyIteration?.prompt_tokens_consumed);
            completionTokensConsumed = await determine(pyIteration?.completion_tokens_consumed);
            rawOutput = await pyIteration?.raw_output;
            parsedOutput = await determine(pyIteration?.parsed_output);
            validationOutput = await determine(pyIteration?.validation_output);
            validatedOutput = await determine(pyIteration?.validated_output);
            const pyReasks = await pyIteration?.reasks;
            reasks = await map(pyReasks, ReAsk.fromPyReAsk);
            const pyValidatorLogs = await pyIteration?.validator_logs;
            validatorLogs = await map(pyValidatorLogs, ValidatorLogs.fromPyValidatorLogs);
            error = await pyIteration?.error;
            exception = await determine(pyIteration?.exception);
            const pyFailedValidations = await pyIteration?.failed_validations;
            failedValidations = await map(pyFailedValidations, ValidatorLogs.fromPyValidatorLogs);
            status = await pyIteration?.status;
        }
        catch (err) {
            console.error('An error occurred while parsing an Iteration from python to javascript.', err);
        }
        return new Iteration(inputs, outputs, logs, tokensConsumed, promptTokensConsumed, completionTokensConsumed, rawOutput, parsedOutput, validationOutput, validatedOutput, reasks, validatorLogs, error, exception, failedValidations, status);
    }
    get inputs() {
        return this._inputs;
    }
    get outputs() {
        return this._outputs;
    }
    get logs() {
        return this._logs;
    }
    get tokensConsumed() {
        return this._tokensConsumed;
    }
    get promptTokensConsumed() {
        return this._promptTokensConsumed;
    }
    get completionTokensConsumed() {
        return this._completionTokensConsumed;
    }
    get rawOutput() {
        return this._rawOutput;
    }
    get parsedOutput() {
        return this._parsedOutput;
    }
    get validationOutput() {
        return this._validationOutput;
    }
    get validatedOutput() {
        return this._validatedOutput;
    }
    get reasks() {
        return this._reasks;
    }
    get validatorLogs() {
        return this._validatorLogs;
    }
    get error() {
        return this._error;
    }
    get exception() {
        return this._exception;
    }
    get failedValidations() {
        return this._failedValidations;
    }
    get status() {
        return this._status;
    }
}
