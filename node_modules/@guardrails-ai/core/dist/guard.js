import { python } from './python.js';
import { ValidationOutcome } from './outputs/validation-outcome.js';
import { Call } from './history/call.js';
import { Stack } from './structs/stack.js';
import { map } from './utils/map.js';
import { isNil } from './utils/is-nil.js';
const { Guard: PyGuard } = await python('guardrails');
export class Guard {
    pyGuard;
    _history;
    constructor(pyGuard) {
        this.pyGuard = pyGuard;
        this._history = new Stack();
    }
    static async fromRail(railFile, opts = {}) {
        // Using the $ postfixed methods lets you pass kwargs as an object
        const pyGuard = await PyGuard.from_rail$(railFile, opts);
        const outputType = await pyGuard.rail.output_type;
        if (outputType === 'str') {
            return new Guard(pyGuard);
        }
        return new Guard(pyGuard);
    }
    static async fromRailString(railString, opts = {}) {
        const kwargs = {
            num_reasks: opts.numReasks
        };
        const pyGuard = await PyGuard.from_rail_string$(railString, kwargs);
        const outputType = await pyGuard.rail.output_type;
        if (outputType === 'str') {
            return new Guard(pyGuard);
        }
        return new Guard(pyGuard);
    }
    static async fromString(validators, opts = {}) {
        const { description, instructions, numReasks, prompt, reaskPrompt, reaskInstructions } = opts;
        const kwargs = {
            description: description,
            instructions: instructions,
            num_reasks: numReasks,
            prompt: prompt,
            reask_prompt: reaskPrompt,
            reask_instructions: reaskInstructions
        };
        const pyGuard = await PyGuard.from_string$(validators, kwargs);
        return new Guard(pyGuard);
    }
    async parse(llmOutput, opts = {}) {
        try {
            const { metadata, numReasks, promptParams, fullSchemaReask, kwargs } = opts;
            if (numReasks && numReasks > 0) {
                console.warn('Reasking is not yet supported.  The value for numReasks will be ignored and set to 0.');
            }
            if (!isNil(fullSchemaReask)) {
                console.warn('Reasking is not yet supported.  The value for fullSchemaReask will be ignored.');
            }
            const response = await this.pyGuard.parse$(llmOutput, {
                metadata,
                num_reasks: 0,
                prompt_params: promptParams,
                full_schema_reask: true,
                ...kwargs
            });
            return ValidationOutcome.fromPyValidationOutcome(response);
        }
        finally {
            await this.cloneProperties();
        }
    }
    async cloneProperties() {
        // Leave room for other properties
        await this.cloneHistory();
    }
    async cloneHistory() {
        const pyHistory = await this.pyGuard.history;
        const callArray = await map(pyHistory, (Call.fromPyCall));
        const callStack = new Stack(...callArray);
        this._history = callStack;
    }
    get history() {
        return this._history;
    }
}
