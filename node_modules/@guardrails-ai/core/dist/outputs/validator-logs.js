import { determine } from '../utils/determine.js';
import { ValidationResult } from './validation-result.js';
export class ValidatorLogs {
    _validatorName;
    _valueBeforeValidation;
    _validationResult;
    _valueAfterValidation;
    constructor(validatorName, valueBeforeValidation, validationResult, valueAfterValidation) {
        this._validatorName = validatorName;
        this._valueBeforeValidation = valueBeforeValidation;
        this._validationResult = validationResult;
        this._valueAfterValidation = valueAfterValidation;
    }
    static async fromPyValidatorLogs(pyValidatorLogs) {
        let validatorName, valueBeforeValidation, validationResult, valueAfterValidation;
        try {
            validatorName = await pyValidatorLogs?.validator_name;
            valueBeforeValidation = await determine(pyValidatorLogs?.value_before_validation);
            const pyValidationResult = await pyValidatorLogs?.validation_result$;
            validationResult = pyValidationResult && await ValidationResult.fromPyValidationResult(pyValidationResult);
            valueAfterValidation = await determine(pyValidatorLogs?.value_after_validation$);
        }
        catch (error) {
            console.error('An error occurred while parsing ValidatorLogs from python to javascript.', error);
        }
        return new ValidatorLogs(validatorName, valueBeforeValidation, validationResult, valueAfterValidation);
    }
    get validatorName() {
        return this._validatorName;
    }
    get valueBeforeValidation() {
        return this._valueBeforeValidation;
    }
    get validationResult() {
        return this._validationResult;
    }
    get valueAfterValidation() {
        return this._valueAfterValidation;
    }
}
